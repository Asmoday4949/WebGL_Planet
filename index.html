<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="./css/stylesheet.css">

		<script src="./js/commonFunctions.js"></script>
		<script src='./js/gl-matrix-min.js'></script>
		<script src='./js/webglTools.js'></script>
		<script src="./js/External/simplex-noise.js"></script>
		<script src="./js/TP/Tools.js"></script>
		<script src="./js/TP/Entity.js"></script>
		<script src="./js/TP/IcoSphere.js"></script>
		<script src='./js/TP/Terrain.js'></script>
		<script src="./js/TP/FpsCounter.js"></script>
		<script src="./js/TP/Camera.js"></script>

		<script id="shader-vs" type="x-shader/x-vertex">
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform float uSeaLevel;
			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;
			varying vec3 vVertexPosition;
			varying vec3 vOriginalVertexPosition;

			void main(void)
			{
				vVertexPosition = aVertexPosition;
				vOriginalVertexPosition = aVertexPosition;

				if(length(aVertexPosition) < uSeaLevel)
				{
					vVertexPosition = normalize(vVertexPosition) * uSeaLevel;
				}

				gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			varying vec3 vVertexPosition;
			varying vec3 vOriginalVertexPosition;

			uniform float uSeaLevel;
			uniform float uWave;

			//uniform vec3 vHeightColorsSet1;
			//uniform vec3 vHeightColorsSet2;
			//uniform vec3 vHeightColorsSet3;

			void main(void)
			{
				vec4 currentColor = vec4(1.0,1.0,1.0,1.0);
				float height = length(vOriginalVertexPosition);

				vec4 heightColor1;
				vec4 heightColor2;
				float percent;

				float seaLevel = 1.0;

				vec4 color0 = vec4(0.131, 0.139, 0.776, 1.0);
        vec4 color1 = vec4(0.505, 0.623, 0.905, 1.0);
        vec4 color2 = vec4(0.674, 0.788, 1.000, 1.0);
        vec4 color3 = vec4(0.074, 0.494, 0.188, 1.0);
        vec4 color4 = vec4(0.549, 0.599, 0.315, 1.0);
        vec4 color5 = vec4(0.890, 0.792, 0.439, 1.0);
        vec4 color6 = vec4(0.627, 0.858, 0.915, 1.0);
        vec4 color7 = vec4(0.901, 0.945, 0.941, 1.0);
        vec4 color8 = vec4(1.000, 1.000, 1.000, 1.0);

				float level0 = uSeaLevel - 0.020;
				float level1 = uSeaLevel - 0.001;
				float level2 = uSeaLevel + 0.001;
				float level3 = uSeaLevel + 0.005;
				float level4 = uSeaLevel + 0.045;
				float level5 = uSeaLevel + 0.060;
				float level6 = uSeaLevel + 0.070;
				float level7 = uSeaLevel + 0.075;
				float level8 = uSeaLevel + 0.080;

				if(height < level0)
				{
					heightColor1 = color0;
					heightColor2 = heightColor1;
					percent = 1.0;
				}
				else if(height < level1)
        {
					heightColor1 = color0;
					heightColor2 = color1;
					percent = (level1 - height) / (level1 - level0);
        }
				else if(height < level2)
        {
					heightColor1 = color1;
					heightColor2 = color2;
					percent = (level2 - height) / (level2 - level1) + uWave;

					if(percent > 1.0)
						percent = -1.0;
        }
			  else if(height < level3)
        {
					heightColor1 = color2;
					heightColor2 = color3;
					percent = (level3 - height) / (level3 - level2);
        }
        else if(height < level4)
        {
					heightColor1 = color3;
					heightColor2 = color4;
					percent = (level4 - height) / (level4 - level3);
        }
				else if(height < level5)
				{
					heightColor1 = color4;
					heightColor2 = color5;
					percent = (level5 - height) / (level5 - level4);
				}
				else if(height < level6)
				{
					heightColor1 = color5;
					heightColor2 = color6;
					percent = (level6 - height) / (level6 - level5);
				}
				else if(height < level7)
				{
					heightColor1 = color6;
					heightColor2 = color7;
					percent = (level7 - height) / (level7 - level6);
				}
				else
				{
					heightColor1 = color7;
					heightColor2 = color8;
					percent = (level8 - height) / (level8 - level7);
				}

				currentColor = heightColor1 * percent + heightColor2 * (1.0 - percent);
				gl_FragColor = currentColor;
			}
		</script>

		<script>
			var mat4 = glMatrix.mat4;
			var vec3 = glMatrix.vec3;
			var vec4 = glMatrix.vec4;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			var vMatrix = mat4.create();

			var camera = new Camera(500, 500);
			var icoSphere = new IcoSphere(camera, 6, false);
			var fpsCounter = new FpsCounter();

			// Init shaders
			function initShaderParameters(prg)
			{
				//prg.pMatrixUniform = glContext.getUniformLocation(prg, 'uPMatrix');
		    //prg.mvMatrixUniform = glContext.getUniformLocation(prg, 'uMVMatrix');
				camera.setupShader(prg);
				icoSphere.setupShader(prg);
			}

			// Init webGL buffers
			function initBuffers()
			{
				camera.update();
				icoSphere.scale(100);
				icoSphere.createGeometry();
			}

			// Draw all the scene
			function drawScene()
			{
				glContext.useProgram(prg);
				glContext.clearColor(0.0, 0.0, 0.0, 1.0);
				glContext.enable(glContext.DEPTH_TEST);
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.viewport(0, 0, c_width, c_height);

				mat4.identity(mvMatrix);
				mat4.multiply(mvMatrix, camera.getView(), icoSphere.getModel());

				// Comment passer le model de chaque objet ?
				// Passer le model à partir des objets directement au shader ?
				// Passer tous les objets dans la camera et parcours tous les objets pour obtenir les model ?
				// Séparer le model de la view et de la projection
				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, camera.getProjection());
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
				//icoSphere.rotateY(Math.PI / 100);

				// check if input has been pressed and execute movement to the camera
				executeInput();

				icoSphere.render();
				fpsCounter.update();
			}

			// Init webGL
			function initWebGL()
			{
				glContext = getGLContext('webgl-canvas');

				//programsDict = initPrograms(["terrain-shader", "water-shader"]);
				//terrainPrg = programsDict["terrain-shader"];
				//waterPrg = programsDict["water-shader"];

				//initTerrainShaderParameters(terrainPrg);
				//initWaterShaderParameters(waterPrg);

				initProgram();
				initBuffers();
				renderLoop();
			}

			let inputState = 0;
			let startTime = Date.now();
			// Execute movements on the camera
			function executeInput()
			{
				let angle = Math.PI / 360.0;
				let move = 1.0;

				let elapsedTime = (Date.now() - startTime)/10;
				startTime = Date.now();

				switch(inputState)
				{
					case 0:
						// Nothing
						break;
					case 1:
						camera.moveForward(move, elapsedTime);
						break;
					case 2:
						camera.moveBackward(move, elapsedTime);
						break;
					case 3:
						camera.rotate(angle, elapsedTime);
						break;
					case 4:
						camera.rotate(-angle, elapsedTime);
						break;
				}

				camera.update();
				icoSphere.createGeometry();
			}

		</script>
	</head>
	<body onload="initWebGL()">
		<script>
			displayTitle("TP: Génération procédurale de terrain", 1, 1, 1, 1, 1, 1, 1);
		</script>

		<p>Cette application webGL permet la génération de terrain d'une planète de manière procédurale. Elle comporte deux catégories de paramètres modifiables :
		<ol>
			<li>statiques: tous les paramètres modifiés doivent obligatoirement être valider afin de regénérer la planète.</li>
			<li>dynamique: tous les paramètres sont appliqués en direct et ne nécessite aucune validation.</li>
		</ol>

		<h2>Paramètres statiques</h2>
		<br>
		<label for="seed-txt">Graine : </label>
		<input type="text" name="seed" id="seed-txt" value="SEED"><button type="button" onclick="rand()" id="random-btn">Random</button><br>

		<label for="layer1mul">Répétition du pattern 1 : </label>
		<input type="number" name="layer1mul" id="layer1-multiply" value="0.5" min="0.0" max="1.0" step="0.05">
		<label for="layer1div">Hauteur 1 : </label>
		<input type="number" name="layer1div" id="layer1-divisor"  value="0.5" min="0.0" max="1.0" step="0.05"><br>

		<label for="layer2mul">Répétition du pattern 2 : </label>
		<input type="number" name="layer2mul" id="layer2-multiply" value="0.5" min="0.0" max="1.0" step="0.05">
		<label for="layer2div">Hauteur 2 : </label>
		<input type="number" name="layer2div" id="layer2-divisor" value="0.5" min="0.0" max="1.0" step="0.05"><br>

		<br>
		<button type="button" onclick="apply()" id="apply-btn">Apply</button>
		<br>

		<h2>Paramètres dynamiques</h2>
		<br>
		<label for="wireframe-checkbox">Wireframe : </label>
		<input type="checkbox" id="wireframe-checkbox" onclick="setWireframeMode()"><br>

		<label for="lod-distance">Distance de LOD : </label>
		<input type="number" name="lod" id="lod-distance" min="1" max="3"><br>

		<label for="sea-level">Niveau de la mer : </label>
		<input type="range" min="0.0" max="1.0" value="0.5" step="0.01" onchange="updateSeaLevel()" class="slider" id="sea-level"></input>

		<h2>Résultat</h2>

		<br>
		<div id="fps-counter">FPS : 0</div>
		<canvas id="webgl-canvas" width="500" height="500">HTML5 is not supported</canvas>



		<h2>Objectifs primaires</h2>
		<ul>
			<li>Creation d'une planète à l'aide l'icosaèdre subdivisé</li>
			<li>Génération de hauteurs différentes pour le terrain</li>
			<li>Génération déterministe de terrain (à l'aide d'une graine)</li>
			<li>Mise en place d'un système de "LOD" naif</li>
			<li>Définir une couleur selon la hauteur du terrain</li>
		</ul>

		<h2>Objectifs secondaires</h2>
		<ul>
			<li>Ajout de textures pour les différents niveaux du terrain</li>
			<li>Ajout d'éléments de décores afin de rendre plus cohérent l'environnement</li>
			<li>Amélioration du système de "LOD" (octree ?)</li>
		</ul>

		<h2>Sphère</h2>
		<p>Pour la création de la sphère, j'ai utilisé l'icosèdre avec subidivision. Cette technique permet d'avoir des sphères uniforme.
		Une première technique pour diminuer l'empreinte mémoire a été de vérifier si un triangle voisin n'as pas déjà effectuer l'opération de "midpoint" sur un de ses cotés.
		Si le vertex n'est pas encore créé, on le créé et autrement on va le rechercher dans un cache afin de récupérer l'indice de ce vertex existants.
		La seconde est d'utiliser un système de "LOD" (Level of Details). L'idée est d'augmenter le nombre de vertices de la partie intéressante de notre mesh. C'est-à-dire
	 que plus la caméra est proche d'une zone d'intérêt, plus le nombre de vertices sera important. Moins la zone a d'intérêt, moins le nombre de vertices est important.</p>

		<h2>Reliefs</h2>
		<p>La création de reliefs sur la sphère a été effectué avec l'algorithme "Simplex Noise" (bruit de perlin améliorée).
			Cet algorithme permet de créer du bruit de perlin, ce qui me permet de générer des hauteurs pour tous les vertices de mon terrain.
			Un autre avantage, c'est qu'il est déterministe. ... continue</p>

		<h2>Couleurs/textures</h2>
		<p>Les couleurs de la planète sont définies en fonction de la hauteur des vertices.</p>

	</body>
	<script>
	fpsCounter.setDiv(document.getElementById("fps-counter"));

	let angle = 0.0;

	// Apply parameters and recreate terrain/planet
	function apply()
	{
		let seed = document.getElementById("seed-txt").value;

		let layer1Mul = document.getElementById("layer1-multiply").value;
		let layer1Div = document.getElementById("layer1-divisor").value;
		let layer2Mul = document.getElementById("layer2-multiply").value;
		let layer2Div = document.getElementById("layer2-divisor").value;

		layer1Mul = convertNormalizedValue(0.0, 6.0, layer1Mul);
		layer2Mul = convertNormalizedValue(0.0, 6.0, layer2Mul);
		layer1Div = convertNormalizedValue(1.0, 30.0, layer1Div, true);
		layer2Div = convertNormalizedValue(1.0, 30.0, layer2Div, true);

		icoSphere.setWireframe(false);
		icoSphere.setSeed(seed);
		icoSphere.setTopographyLayers(layer1Mul, layer1Div, layer2Mul, layer2Div);
		icoSphere.createGeometry();
	}

	// Create random seed
	function rand()
	{
		let randomSeed = generateSeed();
		document.getElementById("seed-txt").value = randomSeed;
	}

	// Set the wireframe mode
	function setWireframeMode()
	{
		let enableWireframe = document.getElementById("wireframe-checkbox").checked;
		icoSphere.setWireframe(enableWireframe);
	}

	// Update the sea level of the planet
	function updateSeaLevel()
	{
		let seaLevelSlider = document.getElementById("sea-level");

		let seaLevel = convertNormalizedValue(0.9, 1.1, seaLevelSlider.value);

		icoSphere.setSeaLevel(seaLevel);
		seaLevelSlider.innerHTML = seaLevel;
	}

	// Detect key pressed and enable movement
	function onKeyDown(e)
	{
		e = e || window.event;

		if(e.repeat == false)
		{
			startTime = Date.now();

			if (e.key == 'w')
			{
				inputState = 1;
			}
			if (e.key == 's')
			{
				inputState = 2;
			}
			if (e.key == 'a')
			{
				inputState = 3;
			}
			if (e.key == 'd')
			{
				inputState = 4;
			}
		}
	}

	// Detect when key is released and disable movement
	function onKeyUp(e)
	{
		inputState = 0;
	}

	// Add keyboard events
	document.onkeydown = onKeyDown;
	document.onkeyup = onKeyUp;

	</script>
</html>
